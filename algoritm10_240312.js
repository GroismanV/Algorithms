//Бинарное дерево
class Leaf {
    constructor(value) {
        this.value = value;
        this.left = null;
        this.right = null;
    }
}

class Tree {
    constructor(value) {
        this.root = new Leaf(value);
    }

    addLeaf(value) {
        let current = this.root;
        while (true) {
            if (value < current.value) {
                if (current.left == null) {
                    current.left = new Leaf(value);
                    break;
                } else current = current.left;
            } else {
                if (current.right == null) {
                    current.right = new Leaf(value);
                    break;
                } else current = current.right;
            }
        }
    }
}

let tree = new Tree(10);
tree.addLeaf(12);
tree.addLeaf(15);
tree.addLeaf(8);
tree.addLeaf(0);
tree.addLeaf(5);
console.log(tree.root.left.left.right.value);

hasLeaf(value) {
    let current = this.root;
    while (true) {
        if (value == current.value) return true;
        else if (value < current.value) {
            if (current.left == null) {
                return false;
            } else current = current.left;
        } else {
            if (current.right == null) {
                return false;
            } else current = current.right;
        }
    }
}


// Этот код представляет собой метод(или функцию) с именем removeLeaf, который предназначен для удаления листа с определенным значением из бинарного дерева поиска.Вот краткое описание алгоритма:

// Проверяется, существует ли лист с заданным значением в дереве с помощью метода hasLeaf.
//     Если такого листа не существует, выбрасывается исключение с сообщением "We don't have the leaf you're looking for".
//     Если значение равно корневому значению дерева, выбрасывается исключение с сообщением "You can't uproot the whole tree".То есть нельзя удалить корневой узел, так как это приведет к удалению всего дерева.
//     В противном случае начинается итеративный процесс удаления узла с заданным значением.Алгоритм использует цикл while, который продолжает выполняться до тех пор, пока не будет найден узел для удаления.
//     В цикле сравнивается значение с текущим узлом(current.value).Если значение меньше, чем значение текущего узла, то происходит движение влево; если больше, то движение вправо.
//     Когда достигнут узел, содержащий значение, которое нужно удалить, соответствующее поддерево(левое или правое) устанавливается в null, что приводит к удалению листа из дерева.
//     Цикл прерывается с использованием оператора break.

// Этот алгоритм предполагает, что дерево является бинарным деревом поиска, и значение узлов в левом поддереве меньше значения корневого узла, а значения в правом поддереве больше.

removeLeaf(value) {
    if (this.hasLeaf(value) == false)
        throw new Error("We don't have the leaf you're looking for");
    if (value == this.root.value)
        throw new Error("You can't uproot the whole tree");

    let current = this.root;
    while (true) {
        if (value < current.value) {
            if (value == current.left.value) {
                current.left = null;
                break;
            } else current = current.left;
        } else {
            if (value == current.right.value) {
                current.right = null;
                break;
            } else current = current.right;
        }
    }
}
// Этот код представляет собой рекурсивную функцию для подсчета количества узлов в бинарном дереве.Функция принимает узел дерева в качестве аргумента и возвращает количество узлов в этом поддереве.

// Алгоритм работает следующим образом:

//     Если узел(leaf) равен null, то возвращается 0, так как пустое поддерево не содержит узлов.
//     В противном случае, возвращается 1(текущий узел), плюс результат вызова функции для левого поддерева(leaf.left) и правого поддерева(leaf.right).Таким образом, общее количество узлов в поддереве равно 1 плюс количество узлов в левом поддереве и количество узлов в правом поддереве.

// Этот алгоритм подсчета узлов в бинарном дереве может быть использован, например, для определения размера дерева.

count(leaf) {
    if (leaf == null) return 0;
    return 1 + this.count(leaf.left) + this.count(leaf.right);
}

// Код, который вы предоставили, является рекурсивной функцией подсчета суммы значений узлов в бинарном дереве.Давайте разберем, как работает этот алгоритм:

//     Если узел(leaf) равен null, то возвращается 0. Это базовый случай рекурсии, который говорит о том, что если узел пуст(отсутствует), то сумма значений в этом поддереве равна 0.

//     В противном случае, если узел не является null, возвращается сумма значений в текущем узле(leaf.value) и сумм значений в его левом поддереве(this.count(leaf.left)) и правом поддереве(this.count(leaf.right)).Это достигается путем рекурсивного вызова функции count для левого и правого поддеревьев узла.

// Таким образом, эта функция подсчитывает общую сумму значений в бинарном дереве.Она начинает с корня дерева и рекурсивно обходит все узлы, добавляя их значения к общей сумме.Поскольку каждый узел добавляет свое значение плюс сумму значений его левого и правого поддеревьев, в итоге получается общая сумма значений всех узлов в дереве.

count(leaf) {
    if (leaf == null) return 0;
    return leaf.value + this.count(leaf.left) + this.count(leaf.right);
}


// Код, который вы предоставили, представляет собой рекурсивную функцию для определения высоты бинарного дерева.Давайте разберем, как работает этот алгоритм:

//     Если узел(leaf) равен null, то возвращается 0. Это базовый случай рекурсии, который говорит о том, что если узел пуст(отсутствует), то его высота равна 0.

//     В противном случае, если узел не является null, возвращается 1 плюс максимальная высота из его левого поддерева(this.height(leaf.left)) и правого поддерева(this.height(leaf.right)).Функция Math.max используется для определения максимального значения между высотами левого и правого поддеревьев.

// Эта функция рекурсивно обходит бинарное дерево, начиная с указанного узла(leaf).Она возвращает высоту поддерева, исходя из максимальной длины пути от указанного узла до самого удаленного листа.Таким образом, она измеряет высоту дерева в терминах количества уровней узлов.
height(leaf) {
    if (leaf == null) return 0;
    return 1 + Math.max(this.height(leaf.left), this.height(leaf.right));
}

